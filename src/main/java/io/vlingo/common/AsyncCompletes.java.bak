// Copyright Â© 2012-2020 VLINGO LABS. All rights reserved.
//
// This Source Code Form is subject to the terms of the
// Mozilla Public License, v. 2.0. If a copy of the MPL
// was not distributed with this file, You can obtain
// one at https://mozilla.org/MPL/2.0/.

package io.vlingo.common;

import java.util.Date;
import java.util.List;
import java.util.Optional;
import java.util.Queue;
import java.util.concurrent.CompletionException;
import java.util.concurrent.ConcurrentLinkedQueue;
import java.util.concurrent.CopyOnWriteArrayList;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.AtomicReference;
import java.util.function.Consumer;
import java.util.function.Function;

import io.vlingo.common.message.AsyncMessageQueue;
import io.vlingo.common.message.Message;
import io.vlingo.common.message.MessageQueue;
import io.vlingo.common.message.MessageQueueListener;

public class AsyncCompletes<T> implements Completes<T> {
  private static final long NoTimeout = -1L;

  static final AtomicReference<CompletionRunner<State>> CompletionRunner = new AtomicReference<>();

  private final State state;

  public AsyncCompletes(final CompletesId id, final Scheduler scheduler) {
    this(new State(id, scheduler));
  }

  public AsyncCompletes(final Scheduler scheduler) {
    this(new CompletesId(), scheduler);
  }

  public AsyncCompletes(final CompletesId id, final T outcome, final boolean successful) {
    this(new State(id, null));

    final boolean actuallySuccessful =
            (outcome instanceof Failure) ? false : successful;

    if (!actuallySuccessful) {
      state.registerFailureOutcomeValue(outcome);
    }

    with(outcome);
  }

  public AsyncCompletes(final T outcome, final boolean successful) {
    this(new CompletesId(), outcome, successful);
  }

  public AsyncCompletes(final CompletesId id, final T outcome) {
    this(new State(id, null));

    with(outcome);
  }

  public AsyncCompletes(final T outcome) {
    this(new CompletesId(), (T) null);
  }

  public AsyncCompletes(final CompletesId id) {
    this(new State(id, null));
  }

  public AsyncCompletes() {
    this(new CompletesId());
  }

  @Override
  @SuppressWarnings("unchecked")
  public <O> Completes<O> andThen(final long timeout, final O failedOutcomeValue, final Function<T, O> function) {
    state.apply(ActionType.Successful, "andThen", timeout, failedOutcomeValue, function, false);
    return (Completes<O>) this;
  }

  @Override
  public <O> Completes<O> andThen(final O failedOutcomeValue, final Function<T, O> function) {
    return andThen(NoTimeout, failedOutcomeValue, function);
  }

  @Override
  public <O> Completes<O> andThen(final long timeout, final Function<T, O> function) {
    return andThen(timeout, null, function);
  }

  @Override
  public <O> Completes<O> andThen(final Function<T, O> function) {
    return andThen(NoTimeout, null, function);
  }

  @Override
  public Completes<T> andThenConsume(final long timeout, final T failedOutcomeValue, final Consumer<T> consumer) {
    state.apply(ActionType.Successful, "andThenConsume", timeout, failedOutcomeValue, consumer);
    return this;
  }

  @Override
  public Completes<T> andThenConsume(final T failedOutcomeValue, final Consumer<T> consumer) {
    return andThenConsume(-1, failedOutcomeValue, consumer);
  }

  @Override
  public Completes<T> andThenConsume(final long timeout, final Consumer<T> consumer) {
    return andThenConsume(timeout, null, consumer);
  }

  @Override
  public Completes<T> andThenConsume(final Consumer<T> consumer) {
    return andThenConsume(-1, null, consumer);
  }

  @Override
  @SuppressWarnings("unchecked")
  public <F, O> O andThenTo(final long timeout, final F failedOutcomeValue, final Function<T, O> function) {
    state.apply(ActionType.Successful, "andThenTo", timeout, failedOutcomeValue, function, true);
    return (O) this;
  }

  @Override
  public <F, O> O andThenTo(final F failedOutcomeValue, final Function<T, O> function) {
    return andThenTo(NoTimeout, failedOutcomeValue, function);
  }

  @Override
  public <O> O andThenTo(final long timeout, final Function<T, O> function) {
    return andThenTo(timeout, null, function);
  }

  @Override
  public <O> O andThenTo(final Function<T, O> function) {
    return andThenTo(NoTimeout, null, function);
  }

  @Override
  public <E> Completes<T> otherwise(final Function<E, T> function) {
    state.apply(ActionType.Failure, "otherwise", NoTimeout, null, function, false);
    return this;
  }

  @Override
  public Completes<T> otherwiseConsume(final Consumer<T> consumer) {
    state.apply(ActionType.Failure, "otherwiseConsume", NoTimeout, null, consumer);
    return this;
  }

  @Override
  public Completes<T> recoverFrom(final Function<Exception, T> function) {
    state.apply(ActionType.Exceptional, "recoverFrom", NoTimeout, null, function, false);
    return this;
  }

  @Override
  @SuppressWarnings("unchecked")
  public <O> Completes<O> andFinally() {
    // no-op
    return (Completes<O>) this;
  }

  @Override
  @SuppressWarnings("unchecked")
  public <O> Completes<O> andFinally(final Function<T, O> function) {
    state.apply(ActionType.Successful, "andFinally", NoTimeout, null, function, false);
    return (Completes<O>) this;
  }

  @Override
  public void andFinallyConsume(final Consumer<T> consumer) {
    state.apply(ActionType.Successful, "andFinallyConsume", NoTimeout, null, consumer);
  }

  @Override
  @SuppressWarnings("unchecked")
  public <O> O await() {
    state.await();
    final O outcome = (O) outcome();
    // debug("AWAIT: OUTCOME: " + outcome + printLimitedTrace(1, 5));
    return outcome;
  }

  @Override
  @SuppressWarnings("unchecked")
  public <O> O await(final long timeout) {
    if (state.await(timeout)) {
      return (O) outcome();
    }
    return null;
  }

  @Override
  public boolean isCompleted() {
    return state.isCompleted();
  }

  @Override
  public boolean hasFailed() {
    return state.hasFailed();
  }

  @Override
  public void failed() {
    with(state.failureValue());
  }

  @Override
  public void failed(final Exception exception) {
    state.exceptionalWith(exception);
  }

  @Override
  public CompletesId id() {
    return state.id();
  }

  @Override
  public boolean hasOutcome() {
    return state.hasFinalOutcome();
  }

  @Override
  @SuppressWarnings("unchecked")
  public T outcome() {
    // debug("ASYNC-COMPLETES: OUTCOME: " + state.finalOutcome() + printLimitedTrace(1, 7));
    return (T) state.finalOutcome();
  }

  @Override
  public Completes<T> repeat() {
    state.repeats();
    return this;
  }

  @Override
  public Completes<T> timeoutWithin(final long timeout) {
    state.startTimer(timeout);
    return this;
  }

  @Override
  public <F> Completes<T> useFailedOutcomeOf(final F failedOutcomeValue) {
    state.registerFailureOutcomeValue(failedOutcomeValue);
    return this;
  }

  @Override
  public <O> Completes<O> uponCompletion(final Function<T, O> onFailure, final Function<T, O> onSuccess) {
    if (hasFailed()) {
      return new AsyncCompletes<>(onFailure.apply(outcome()), false);
    }
    return new AsyncCompletes<>(onSuccess.apply(outcome()), true);
  }

  @Override
  @SuppressWarnings("unchecked")
  public <O> Completes<O> with(final O outcome) {
    // debug("ASYNC-COMPLETES: WITH: OUTCOME: " + outcome + printLimitedTrace(1, 5));
    state.completeWith(outcome);
    return (Completes<O>) this;
  }

  @Override
  public String toString() {
    return "AsyncCompletes [state=" + state + "]";
  }

//  private static boolean DEBUG = true;
//
//  private static void debug(final String message) {
//    if (DEBUG) {
//      synchronized (AsyncCompletes.class) {
//        System.out.println(message);
//      }
//    }
//  }
//
//  private static String printLimitedTrace(final int startingWith, final int levels) {
//    return printLimitedTrace(new Exception(), startingWith, levels);
//  }
//
//  private static String printLimitedTrace(final int levels) {
//    return printLimitedTrace(new Exception(), -1, levels);
//  }
//
//  private static String printLimitedTrace(final Throwable t, final int levels) {
//    return printLimitedTrace(t, -1, levels);
//  }
//
//  private static String printLimitedTrace(final Throwable t, final int startingWith, final int levels) {
//    if (DEBUG) {
//      final StringBuilder builder = new StringBuilder();
//      final StackTraceElement[] trace = t.getStackTrace();
//      int idx = startingWith;
//      idx = (idx >= 0) ? idx : trace[1].toString().contains("AsyncCompletes.access$") ? 2 : 1;
//      final int max = Math.min(levels + idx, trace.length);
//      int count = 1;
//      for ( ; idx < max; ++idx) {
//        builder.append("\n").append("TRACE: ").append(count++).append(": ").append(trace[idx]);
//      }
//      return builder.toString();
//    }
//    return "";
//  }

  private AsyncCompletes(final State state) {

    //=======================
    // BOOTSTRAP -- replace
    //=======================
    if (CompletionRunner.get() == null) {
      try {
        Completes.runWithDefault();
      } catch (IllegalStateException e) {
        // do not fail on race
      }
    }

    this.state = state;
  }




  //////////////////////////////////////////////////////
  // State
  //////////////////////////////////////////////////////

  static class State implements Scheduled<Object> {
    private Cancellable cancellable;
    private final AtomicReference<State> childState;
    private final CompletionHandler completionHandler;
    private final AtomicReference<Completion> failureValue;
    private final Queue<Object> finalOutcome;
    private final CompletesId id;
    private final State parent;
    private final AtomicBoolean repeating;
    private final AtomicBoolean repeats;
    private final Scheduler scheduler;

    State(final CompletesId id, final Scheduler scheduler) {
      this(null, id, scheduler);
    }

    State(final State parent, final CompletesId id, final Scheduler scheduler) {
      this.parent = parent;
      // debug((parent == null ? "***** PARENT *****" : "***** CHILD *****") + " ID: " + id);
      this.id = id;
      this.scheduler = scheduler;
      this.childState = new AtomicReference<>(null);
      this.failureValue = new AtomicReference<>(new FailureCompletion(null));
      this.repeating = new AtomicBoolean(false);
      this.repeats = new AtomicBoolean(false);
      this.finalOutcome = new ConcurrentLinkedQueue<>();

      this.completionHandler = new CompletionHandler(this);
    }

    public <T> void apply(
            final ActionType actionType,
            final String name,
            final long timeout,
            final T failedOutcomeValue,
            final Consumer<T> consumer) {

      checkForTerminal();

      if (hasNesting()) {
        // debug("ST: APPLY: " + id() + " NESTED");
        nestedState().apply(actionType, name, timeout, failedOutcomeValue, consumer);
        return;
      }

      registerFailureOutcomeValue(failedOutcomeValue);

      registerAction(actionType, name, consumer);

      startTimer(timeout);
    }

    public <F, T, O> void apply(
            final ActionType actionType,
            final String name,
            final long timeout,
            final F failedOutcomeValue,
            final Function<T, O> function,
            final boolean nested) {

      checkForTerminal();

      if (hasNesting()) {
        // debug("ST: APPLY: " + id() + " NESTED");
        nestedState().apply(actionType, name, timeout, failedOutcomeValue, function, nested);
        return;
      }

      // debug("ST: APPLY: " + id() + " OUTTER");

      final State state = nested ?
              new State(this, new CompletesId(), scheduler) :
              this;

      state.registerFailureOutcomeValue(failedOutcomeValue);

      state.registerAction(actionType, name, function);

      state.startTimer(timeout);

      childState.set(state == this ? null: state);
    }

    public void await() {
      final State child = this.childState.get();
      if (child != null) {
        // debug("ST: AWAIT: " + id() + " TO CHILD");
        child.await();
      } else {
        // debug("ST: AWAIT: " + id() + " DO");
        completionHandler.await();
      }
    }

    public boolean await(final long timeout) {
      final State child = this.childState.get();
      if (child != null) {
        return child.await(timeout);
      }
      return completionHandler.await(timeout);
    }

    public void cancelTimer() {
      if (cancellable != null) {
        cancellable.cancel();
        cancellable = null;
      }
    }

    public boolean isCompleted() {
      return hasCompletedAll();
    }

    public <T> void completeWith(final T outcome) {
      boolean completing = true;

      while (completing) {
        if (repeating.compareAndSet(false, true)) {
          try {
            cancelTimer();

            if (isTimedOut()) {
              // debug("ST: COMPLETE-WITH: " + id + " TIMEOUT SHORT CIRCUIT");
              return;
            } else if (isFailureValue(outcome)) {
              // debug("ST: COMPLETE-WITH: " + id + " FAILURE: " + outcome);
              completionHandler.completion(new FailureCompletion(outcome));
            } else {
              // debug("ST: COMPLETE-WITH: " + id + " SUCCESS: " + outcome + printLimitedTrace(5));
              completionHandler.completion(new SuccessfulCompletion(outcome));
            }
          } finally {
            repeating.set(completing = false);
          }
        }
      }
    }

    public void exceptionalWith(final Exception exception) {
      completionHandler.completion(new ExceptionalCompletion(exception));
    }

    public boolean hasFailed() {
      return completionHandler.hasFailed();
    }

    public <T> T failureValue() {
      return failureValue.get().outcome();
    }

    public <T> boolean isFailureValue(final T candidateFailureValue) {
      if (isTimedOut()) return true;

      final T currentFailureValue = failureValue.get().outcome();

      // debug("ST: IS-FAILURE-VALUE: " + id + " CURRENT: " + currentFailureValue + " =? CANDIDATE: " + candidateFailureValue);

      if (currentFailureValue == candidateFailureValue) return true;

      if (currentFailureValue != null && currentFailureValue.equals(candidateFailureValue)) return true;

      // debug("ST: IS-FAILURE-VALUE: " + id + " NOT");
      return false;
    }

    public CompletesId id() {
      return id;
    }

    public void repeats() {
      repeats.set(true);

      if (!hasTerminalAction()) {
        completionHandler.action(new TerminalAction(ActionType.Terminal, "repeat-terminal", this));
      }
    }

    @Override
    public String toString() {
      return "State [id=" + id + ", parent=" + parent + ", finalOutcome=" + finalOutcome + "]";
    }

    boolean hasNesting() {
      return childState.get() != null;
    }

    State nestedState() {
      return childState.get();
    }

    Object finalOutcome() {
      if (!hasFinalOutcome()) {
        // debug("ST: FINAL-OUTCOME: " + id() + " FROM HANDLER: " + completionHandler.completion().outcome());
        return completionHandler.completion().outcome(); // may also be null
      }

      Object outcome = null;

      for (final Object possibleOutcome : finalOutcome) {
        outcome = possibleOutcome;
      }

      // debug("ST: FINAL-OUTCOME: " + id() + " FROM STATE: " + outcome + printLimitedTrace(5));

      return (outcome instanceof NullValue) ? null : outcome;
    }

    boolean hasFinalOutcome() {
      return !finalOutcome.isEmpty();
    }

    private void checkForTerminal() {
      if (hasTerminalAction()) {
        // throw new IllegalStateException("Cannot apply another expression following a terminal expression.");
      }
    }

    private boolean hasCompletedAll() {
      State state = this;

      while (state != null) {
        final Completion completion = state.completionHandler.completion();

        if (completion.status().isUncompleted()) {
          return false;
        }

        state = nestedState();
      }

      return true;
    }

    private void finalOutcome(final Object finalOutcome) {
      if (finalOutcome == null) {
        this.finalOutcome.add(new NullValue());
      } else {
        this.finalOutcome.add(finalOutcome);
      }
      // debug("ST: FINAL-OUTCOME: "  + id() + " SET TO: " + finalOutcome);
    }

    private <T> void registerAction(final ActionType actionType, final String name, final Consumer<T> consumer) {
      completionHandler.action(new ConsumerAction<>(actionType, name, this, consumer, completionHandler));
      completionHandler.action(new TerminalAction(ActionType.Terminal, name + "-terminal", this));
    }

    private <T, O> void registerAction(final ActionType actionType, final String name, final Function<T, O> function) {
      completionHandler.action(new FunctionAction<>(actionType, name, this, function, completionHandler));
    }

    private <T> void registerFailureOutcomeValue(final T failedOutcomeValue) {
      final T currentFailureValue = failureValue.get().outcome();

      // debug("ST: REGISTER-FAILURE-VALUE: " + id + " CURRENT FAILURE VALUE: " + currentFailureValue);

      if (currentFailureValue == failedOutcomeValue) return;

      if (currentFailureValue != null && failedOutcomeValue == null) return;

      if (currentFailureValue != null && currentFailureValue.equals(failedOutcomeValue)) return;

      // debug("ST: REGISTER-FAILURE-VALUE: " + id + " SETTING FAILURE VALUE: " + failedOutcomeValue);

      failureValue.set(new FailureCompletion(failedOutcomeValue));
    }

    void repeat() {
      if (!hasRepeats()) return;

      boolean performRepeat = true;

      while (performRepeat) {
        if (repeating.compareAndSet(false, true)) {
          try {
            ensureFinalOutcome();
            reset();
          } finally {
            repeating.set(performRepeat = false);
          }
        }
      }
    }

    boolean hasRepeats() {
      return repeats.get();
    }

    private void reset() {
      final State child = this.childState.get();
      if (child != null) {
        child.reset();
      }

      // debug("ST: RESET: " + id());

      truncateFinalOutcome();

      this.completionHandler.reset();

      this.cancellable = null;
    }

    private boolean hasTerminalAction() {
      return completionHandler.hasTerminalAction();
    }

    boolean isTimedOut() {
      return completionHandler.isTimedOut();
    }

    private void ensureFinalOutcome() {
      final State child = this.childState.get();
      if (child != null) {
        child.ensureFinalOutcome();
      }
      // debug("ST: ENSURE FINAL OUTCOME ******************* " + completionHandler.completion().outcome());
      finalOutcome(completionHandler.completion().outcome());
      //completionHandler.done();
    }

    private void startTimer(final long timeout) {
      if (timeout > 0 && scheduler != null && cancellable == null) {
        // 2L delayBefore prevents timeout until after return from here
        cancellable = scheduler.scheduleOnce(this, null, 2L, timeout);
      }
    }

    private void truncateFinalOutcome() {
      final Object truncatedFinalOutcome = finalOutcome();
      this.finalOutcome.clear();
      this.finalOutcome(truncatedFinalOutcome);
      // debug("ST: TRUNCATE-FINAL-OUTCOME: " + id + " TO: " + truncatedFinalOutcome);
    }

    @Override
    public void intervalSignal(final Scheduled<Object> scheduled, final Object data) {
      // favor success over failure when
      // completing and timeout race
      if (completionHandler.isSuccessfulStatus()) {
        // debug("ST: INTERVAL-SIGNAL: " + id + " NO TIMEOUT");
        ;
      } else {
        // debug("ST: INTERVAL-SIGNAL: " + id + " TIMEOUT");
        completionHandler.completion(new FailureCompletion(failureValue.get().outcome(), true));
      }

      cancelTimer();
    }
  }


  //////////////////////////////////////////////////////
  // CompletionHandler
  //////////////////////////////////////////////////////

  static class CompletionHandler implements ActionInterest<State> {
    private List<Action<State>> actions;
    private final AtomicBoolean actionsAccess;
    private final AtomicInteger actionsIndex;
    private final AtomicReference<Completion> completion;
    private CountDownLatch done;
    private final AtomicBoolean failure;
    private final AtomicInteger pendingExecutions;
    private final AtomicBoolean running;
    private final State state;
    private final AtomicBoolean timedOut;
    private final AtomicReference<Action<State>> timeoutFailureAction;
    private final AtomicReference<Action<State>> backupTimeoutFailureAction;

    CompletionHandler(final State state) {
      this.state = state;
      this.actions = new CopyOnWriteArrayList<>();
      this.actionsAccess = new AtomicBoolean(false);
      this.actionsIndex = new AtomicInteger(0);
      this.completion = new AtomicReference<>(new UncompletedCompletion());
      this.failure = new AtomicBoolean(false);
      this.pendingExecutions = new AtomicInteger(0);
      this.running = new AtomicBoolean(false);
      this.timedOut = new AtomicBoolean(false);
      this.timeoutFailureAction = new AtomicReference<>(null);
      this.backupTimeoutFailureAction = new AtomicReference<>(null);
      this.done = new CountDownLatch(1);
    }

    void action(final Action<State> action) {
      // debug("CH: ACTION: " + state.id() + " ADDING ACTION: " + action.id() + " TYPE: " + action.type());

      final boolean hasTerminalAction = hasTerminalAction();

      if (action.isTerminal() && hasTerminalAction) return;

      boolean adding = true;

      while (adding) {
        if (actionsAccess.compareAndSet(false, true)) {
          try {
            // debug("CH: ACTION: " + state.id() + " DEFINITION: " + action);

            if (hasTerminalAction) {
              actions.add(terminalActionIndex(), action);
            } else {
              actions.add(action);
            }

            if (action.type().isFailure() && timeoutFailureAction.get() == null) {
              // debug("CH: ACTION: " + state.id() + " ADDING TIMEOUT FAILURE ACTION: " + action.id() + action.type());
              timeoutFailureAction.set(action);
            }
          } finally {
            actionsAccess.set(adding = false);
          }
        }
      }

      executeWith(completion.get());
    }

    void await() {
      try {
        // debug("CH: AWAIT: " + state.id() + " REMAINING COUNT: " + done.getCount() + " VALUE: " + this.completion().outcome());

        ensureTerminal();

        done.await();
      } catch (InterruptedException e) {
        // fall through
      }
    }

    boolean await(final long timeout) {
      try {
        ensureTerminal();

        return done.await(timeout, TimeUnit.MILLISECONDS);
      } catch (InterruptedException e) {
        return false;
      }
    }

    void completion(final Completion result) {
      executeWith(result);
    }

    Completion completion() {
      return completion.get();
    }

    boolean hasFailed() {
      // debug("CH: HAS-FAILED: " + state.id() + " VALUE: " + failure.get());
      return failure.get();
    }

    @SuppressWarnings("unchecked")
    <T> T outcome() {
      if (state.hasFinalOutcome()) {
        // debug("CH: OUTCOME: FINAL-OUTCOME: " + state.finalOutcome());
        return (T) state.finalOutcome();
      }

      // debug("CH: OUTCOME: FINAL-OUTCOME MISSING USING: " + state.finalOutcome());
      return completion().outcome();
    }

    void reset() {
      // debug("CH: RESET: " + state.id() + " PRE-RESET REMAINING COUNT: " + done.getCount());

      this.done.countDown();

      boolean resetting = true;

      while (resetting) {
        if (actionsAccess.compareAndSet(false, true)) {
          // debug("CH: RESET: " + state.id() + " REMAINING COUNT: " + done.getCount() + " FINAL-OUTCOME: " + state.finalOutcome());
          try {
            this.actionsIndex.set(0);
            this.completion.set(new UncompletedCompletion());
            this.failure.set(false);
            this.running.set(false);
            this.timedOut.set(false);
            this.timeoutFailureAction.set(backupTimeoutFailureAction.get());
            this.done = new CountDownLatch(1);
          } finally {
            actionsAccess.set(resetting = false);
          }
        }
      }
    }

    CompletionStatus status() {
      return completion().status();
    }

    /**
     * Answer whether or not I am the {@code Exceptional} type.
     * @return boolean
     */
    boolean isExceptionalStatus() { return completion.get().status().isExceptional(); }

    /**
     * Answer whether or not I am the {@code Failure} type.
     * @return boolean
     */
    boolean isFailureStatus() { return completion.get().status().isFailure(); }

    /**
     * Answer whether or not I am the {@code Successful} type.
     * @return boolean
     */
    boolean isSuccessfulStatus() { return completion.get().status().isSuccessful(); }

    /**
     * Answer whether or not I am the {@code TimedOut} type.
     * @return boolean
     */
    boolean isTimedOutStatus() { return completion.get().status().isTimedOut(); }

    /**
     * Answer whether or not I am the {@code Uncompleted} type.
     * @return boolean
     */
    boolean isUncompletedStatus() { return completion.get().status().isUncompleted(); }

    private void completeWith(final Completion result) {
      completion.set(result);

      if (result.status().isUncompleted()) {
        // debug("CH: COMPLETE-WITH: " + state.id() + " STATUS: " + result.status() + " SHORT-CIRCUITING EXECUTION");
        return;
      }

      // debug("CH: COMPLETE-WITH: " + state.id() + " STATUS: " + result.status() + " OUTCOME: " + outcome() + " FAILED: " + result.status().hasFailed());

      if (!hasFailed() && result.status().hasFailed()) {
        // debug("CH: COMPLETE-WITH: " + state.id() + "SETTING FAILURE!!!!");
        failure.set(true);
      }

      final Tuple2<Boolean,Boolean> hasNextAction = hasNextAction();

      if (!hasNextAction._1 && hasNesting()) {
        // debug("CH: COMPLETE-WITH: " + state.id() + " NESTED DELEGATION TO: " + state.nestedState().id() + " WITH: " + result.outcome());
        state.nestedState().completeWith(result.outcome());
      } else if (hasNextAction._1 && hasNextAction._2) {
        // debug("CH: COMPLETE-WITH: " + state.id() + " TERMINAL; DONE USING CURRENT RESULT: " + result.outcome());
        done(result.outcome());
      } else if (hasNextAction._2) {
        // debug("CH: COMPLETE-WITH: " + state.id() + " TERMINAL; DONE USING PREVIOUS RESULT");
        done();
      } else {
        // debug("CH: COMPLETE-WITH: " + state.id() + " NOT DONE: " + result.outcome());
        done(result.outcome());
      }
    }

    private void done(final Object finalOutcome) {
      @SuppressWarnings("unchecked")
      final Object realFinalOutcome = (finalOutcome instanceof AsyncCompletes) ?
              ((AsyncCompletes<Object>) finalOutcome).outcome() :
              finalOutcome;

      if (hasParentState()) {
        // debug("CH: DONE: " + state.id() + " CHILD FINAL-OUTCOME: " + realFinalOutcome + " DONE: " + done.getCount());
        parentState().completionHandler.done(realFinalOutcome);
      }

      // debug("CH: DONE: " + state.id() + " PARENT FINAL-OUTCOME: " + realFinalOutcome + " DONE: " + done.getCount());

      state.finalOutcome(realFinalOutcome);

      done();
    }

    private void done() {
      if (state.hasFinalOutcome() && pendingExecutions.get() == 0) {
        // debug("CH: DONE: " + state.id() + " FIRING!!!: " + state.finalOutcome());

        done.countDown();

        state.repeat();
      }
    }

    private void executeNext() {
      if (isUncompletedStatus()) return;

      // debug("CH: EXECUTE-NEXT: " + state.id() + " STATUS: " + status());

      final Action<State> action = nextAction(true);

      if (action == null || action.isTerminal()) {
        // debug("CH: EXECUTE-NEXT: NULL ACTION FOR: " + status() + printLimitedTrace(5));
        return;
      }

      if (hasFailed() && action.type().isSuccessful()) {
        // short circuit
        // debug("CH: EXECUTE-NEXT: " + state.id() + " SHORT CIRCUIT FOR: " + status());
        return;
      }

      // debug("CH: EXECUTE-NEXT: " + state.id() + " EXECUTING NOW: STATUS: " + status());

      execute(action, false);
    }

    private void execute(final Action<State> action, final boolean timedOut) {
      boolean run = true;

      while (run) {
        if (running.compareAndSet(false, true)) {
          try {
            pendingExecutionOf(action);

            messageQueueRunner().runWith(action);
          } finally {
            running.set(run = false);
          }
        }
      }
    }

    private boolean executeTimeout(final Completion result) {
      boolean resultTimedOut = false;

      if (isTimedOutStatus() || (resultTimedOut = (result != null && result.status().isTimedOut()))) {
        // debug("CH: EXECUTE-TIMEOUT: " + state.id() + " RESULT: " + result + " CURRENT: " + completion.get());

        if (resultTimedOut || isTimedOut()) {
          // debug("CH: EXECUTE-TIMEOUT: " + state.id() + " SETTING RESULT: " + result);
          completeWith(result);
        }

        // debug("CH: EXECUTE-TIMEOUT: " + state.id() + " FAILURE ACTION FOR: " + result);
        timeoutFailureAction();

        return true;
      }

      return false;
    }

    private void ensureTerminal() {
      if (!hasTerminalAction()) {
        // debug("CH: ENSURE-AWAIT-TERMINAL-ACTION: " + state.id() + " ADDING TERMINAL AWAIT");
        action(new TerminalAction(ActionType.Terminal, "await-terminal", state));
      } else {
        // debug("CH: ENSURE-AWAIT-TERMINAL-ACTION: " + state.id() + " NOT ADDING TERMINAL AWAIT");
      }

      if (done.getCount() > 0) {
        // debug("CH: ENSURE-AWAIT-TERMINAL-ACTION: " + state.id() + " EXECUTING");
        completeWith(completion.get());
      } else {
        // debug("CH: ENSURE-AWAIT-TERMINAL-ACTION: " + state.id() + " ALREADY EXECUTING");
      }
    }

    private void executeWith(final Completion completion) {
      if (!executeTimeout(completion)) {
        // debug("CH: EXECUTE-WITH: " + state.id() + " COMPLETION: " + completion.outcome() + " STATUS: " + completion.status());

        completeWith(completion);

        executeNext();
      }
    }

    private boolean hasNesting() {
      return state.hasNesting();
    }

    private Tuple2<Boolean,Boolean> hasNextAction() {
      final Action<State> action = nextAction(false);
      final Tuple2<Boolean,Boolean> hasNext = Tuple2.from(action != null, action != null && action.isTerminal());
      // debug("CH: HAS-NEXT-ACTION: " + state.id() + " " + hasNext);
      return hasNext;
    }

    private Action<State> nextAction(final boolean toExecute) {
      // debug("CH: NEXT-ACTION: " + state.id() + " STATUS: " + status());

      Action<State> next = null;

      if (isSuccessfulStatus()) {
        next = nextSuccessAction(toExecute);
      } else if (isFailureStatus()) {
        next = nextFailureAction(toExecute);
      } else if (isTimedOutStatus()) {
        next = nextTimeOutAction(toExecute);
      } else if (isExceptionalStatus()) {
        next = nextExceptionalAction(toExecute);
      }

      if (next == null) {
        next = nextTerminalAction();
      }

      return next;
    }

    private Action<State> nextActionMatching(final ActionType actionType, final boolean toExecute) {
      boolean matching = true;

      while (matching) {
        if (actionsAccess.compareAndSet(false, true)) {
          try {
            int idx = actionsIndex.get();
            for ( ; idx < actions.size(); ++idx) {
              final Action<State> action = actions.get(idx);
              if (action.type() == actionType) {
                // debug("CH: NEXT-ACTION-MATCHING: " + state.id() + " MATCHED AT: " + idx + " ACTION: " + action + " TYPE: " + action.type() + " FOR COMPLETION: " + this.completion);
                if (toExecute) {
                  actionsIndex.set(++idx);
                  // debug("CH: NEXT-ACTION-MATCHING: " + state.id() + " NEXT INDEX: " + idx + " SIZE: " + actions.size());
                  if (idx < actions.size()) {
                    final Action<State> runnable = actions.get(idx);
                    // debug("CH: NEXT-ACTION-MATCHING: " + state.id() + " FOLLOWING ACTION: " + runnable + " TYPE: " + runnable.type());
                  } else {
                    // debug("CH: NEXT-ACTION-MATCHING: " + state.id() + " NO FOLLOWING ACTION FOR: " + actionType);
                  }
                }
                return action;
              }
            }
          } finally {
            actionsAccess.set(matching = false);
          }
        }
      }

      // debug("CH: " + state.id() + " NEXT-ACTION-MATCHING: NOT MATCHED FOR: " + actionType);

      return null;
    }

    private Action<State> nextExceptionalAction(final boolean toExecute) {
      return nextActionMatching(ActionType.Exceptional, toExecute);
    }

    private Action<State> nextFailureAction(final boolean toExecute) {
      return nextActionMatching(ActionType.Failure, toExecute);
    }

    private Action<State> nextSuccessAction(final boolean toExecute) {
      return nextActionMatching(ActionType.Successful, toExecute);
    }

    private Action<State> nextTerminalAction() {
      return nextActionMatching(ActionType.Terminal, false);
    }

    private Action<State> nextTimeOutAction(final boolean toExecute) {
      final Action<State> failureAction = timeoutFailureAction.get();

      if (toExecute) {
        backupTimeoutFailureAction.set(failureAction);
        timeoutFailureAction.set(null);
      }

      return failureAction;
    }

    private boolean hasParentState() {
      return state.parent != null;
    }

    private State parentState() {
      return state.parent;
    }

    private void pendingCompletedFor(final Action<State> action) {
      this.pendingExecutions.decrementAndGet();

      // debug("CH: EXECUTE: " + state.id() + " ACTION: " + action.name() + " COMPLETED -- PENDING: " + pendingExecutions.get());

      done();
    }

    private void pendingExecutionOf(final Action<State> action) {
      this.pendingExecutions.incrementAndGet();

      // debug("CH: EXECUTE: " + state.id() + " ACTION: " + action.name() + " STARTING -- PENDING: " + pendingExecutions.get());
    }

    private boolean hasTerminalAction() {

      return terminalActionIndex() >= 0;
    }

    private int terminalActionIndex() {
      final int count = actions.size();

      if (count > 0 && actions.get(count - 1).isTerminal()) {
        return count - 1;
      }

     return -1;
    }

    private boolean isTimedOut() {
      return this.timedOut.get();
    }

    private void timeoutFailureAction() {
      final Action<State> action = timeoutFailureAction.get();

      timedOut.set(true);

      if (action != null) {
        // debug("CH: " + state.id() + " TIMEOUT-FAILURE-ACTION: EXECUTE TIMEOUT NOW");
        timeoutFailureAction.set(null);
        execute(action, true);
      }
    }

    @Override
    public void actionResultedIn(final boolean success, final Action<State> action, final boolean handledTimeOut) {
      try {
        if (success) {
          // debug("CH: ACTION-RESULTED-IN: " + state.id() + " SUCCESS WITH: " + action.outcome());
          action.outcome().ifPresent(resultingOutcome -> {
            // debug("CH: ACTION-RESULTED-IN: " + state.id() + " OUTCOME IS PRESENT: " + resultingOutcome);
            if (handledTimeOut) {
              // debug("CH: ACTION-RESULTED-IN: " + state.id() + " OUTCOME IS TIMED OUT");
              completeWith(new FailureCompletion(resultingOutcome, true));
            } else if (!state.isFailureValue(resultingOutcome)) {
              // debug("CH: ACTION-RESULTED-IN: " + state.id() + " SUCCESSFUL: " + action.state().id());
              completion(new SuccessfulCompletion(resultingOutcome));
            } else {
              // debug("CH: ACTION-RESULTED-IN: " + state.id() + " FAILURE: " + action.state().id() + " TIMED-OUT: " + action.state().isTimedOut());
              completion(new FailureCompletion(resultingOutcome, action.state().isTimedOut()));
            }
          });
        } else {
          // debug("CH: ACTION-RESULTED-IN: " + state.id() + " FAILURE: EXCEPTION: " + action.exception().getMessage());
          completion(new ExceptionalCompletion(action.exception()));
        }
      } finally {
        pendingCompletedFor(action);
      }
    }
  }


  //////////////////////////////////////////////////////
  // NullValue
  //////////////////////////////////////////////////////

  private static class NullValue { }

  //////////////////////////////////////////////////////
  // Completion
  //////////////////////////////////////////////////////

  /**
   * Abstract base for various concrete {@code Completion} types.
   */
  private static abstract class AbstractCompletion implements Completion {
    private final Object outcome;
    private final CompletionStatus status;

    AbstractCompletion(final Object outcome, final CompletionStatus status) {
      this.outcome = outcome;
      this.status = status;
    }

    @Override
    @SuppressWarnings("unchecked")
    public <O> O outcome() {
      if (outcome instanceof AsyncCompletes) {
        return (O) ((AsyncCompletes<Object>) outcome).outcome();
      }
      return (O) outcome;
    }

    @Override
    public CompletionStatus status() {
      return status;
    }

    @Override
    public String toString() {
      return getClass().getSimpleName() + " [status=" + status + ", outcome=" + outcome + "]";
    }
  }

  private static class SuccessfulCompletion extends AbstractCompletion {
    SuccessfulCompletion(final Object outcome) {
      super(outcome, CompletionStatus.Succeeded);
    }
  }

  private static class FailureCompletion extends AbstractCompletion {
    FailureCompletion(final Object outcome) {
      this(outcome, false);
    }

    FailureCompletion(final Object outcome, final boolean timedOut) {
      super(outcome, timedOut ? CompletionStatus.TimedOut : CompletionStatus.Failed);
    }
  }

  private static class ExceptionalCompletion extends AbstractCompletion {
    ExceptionalCompletion(final Throwable t) {
      super(new CompletionException(t.getMessage(), t), CompletionStatus.Exceptional);
    }
  }

  private static class UncompletedCompletion extends AbstractCompletion {
    UncompletedCompletion() {
      super(null, CompletionStatus.Uncompleted);
    }
  }

  //////////////////////////////////////////////////////
  // Action
  //////////////////////////////////////////////////////

  private static abstract class RunnableAction implements Action<State> {
    private final ActionType actionType;
    private final AtomicReference<Exception> exception;
    private final AtomicBoolean handleTimeOutFailure;
    private final ActionInterest<State> interest;
    private final String name;
    private final State state;

    private static final AtomicInteger nextId = new AtomicInteger(0);
    public final int id;

    RunnableAction(final ActionType actionType, final String name, final State state, final ActionInterest<State> interest) {
      this.id = nextId.incrementAndGet();
      this.actionType = actionType;
      this.name = "" + id + "-" + name;
      this.state = state;
      this.interest = interest;
      this.exception = new AtomicReference<>();
      this.handleTimeOutFailure = new AtomicBoolean(false);

      // debug("A0: CTOR: " + id + " STATE: " + state.id() + " TYPE: " + actionType);
    }

    @Override
    public Exception exception() {
      return exception.get();
    }

    @Override
    public void handleTimeOutFailure(final boolean timedOut) {
      handleTimeOutFailure.set(timedOut);
    }

    @Override
    public ActionInterest<State> interest() {
      return interest;
    }

    @Override
    public String name() {
      return name;
    }

    @Override
    public void reset() {
      exception.set(null);

      handleTimeOutFailure.set(false);
    }

    @Override
    public State state() {
      return state;
    }

    @Override
    public ActionType type() {
      return actionType;
    }

    int id() {
      return id;
    }

    void inform(final boolean success) {
      // debug("A0: INFORM: " + id + " STATE: " + state.id() + " POST EXECUTE SUCCESS: " + success + " TIMEOUT: " + handleTimeOutFailure.get());

      interest.actionResultedIn(success, this, handleTimeOutFailure.get());
    }

    void setException(final Exception e) {
      this.exception.set(e);
    }

    @Override
    public String toString() {
      return getClass().getSimpleName()
              + " [id=" + id() + ", actionType=" + actionType + ", name=" + name + ", isTerminal=" + isTerminal() + ", exception=" + exception
              + ", state=" + state + ", handleTimeOutFailure=" + handleTimeOutFailure + "]";
    }
  }

  private static class ConsumerAction<T> extends RunnableAction {
    private final Consumer<T> consumer;

    ConsumerAction(final ActionType actionType, final String name, final State state, Consumer<T> consumer, final ActionInterest<State> interest) {
      super(actionType, name, state, interest);

      if (consumer == null) throw new NullPointerException("Completes action consumer must not be null.");

      this.consumer = consumer;
    }

    @Override
    public void executeWith(final State state) {
      final T parameter = state.completionHandler.completion().outcome();
      // debug("AC: EXECUTE-WITH: ID: " + id + " ACTION: " + this + " STATE: " + state.id() + " TYPE: " + type() + " STATUS: " + state().completionHandler.status() + " OUTCOME PARAM: " + parameter);
      try {
        // debug("AC: EXECUTE-WITH: " + id() + " STATE: " + state.id() + " TYPE: " + type() + " STATUS: " + state().completionHandler.status());
        consumer.accept(parameter);
        inform(true);
      } catch (Exception e) {
        // debug("AC: EXECUTE-WITH: " + id + " STATE: " + state.id() + " TYPE: " + type() + " EXCEPTION IN CONSUMER: " + e.getMessage() + printLimitedTrace(e, 0, 999));
        setException(e);
        inform(false);
      }
    }
  }

  private static class FunctionAction<T,O> extends RunnableAction {
    private final Function<T,O> function;
    private AtomicReference<O> outcome;

    FunctionAction(final ActionType actionType, final String name, final State state, final Function<T, O> function, final ActionInterest<State> interest) {
      super(actionType, name, state, interest);

      if (function == null) throw new NullPointerException("Completes action function must not be null.");

      this.function = function;

      this.outcome = null;
    }

    @Override
    @SuppressWarnings("unchecked")
    public void executeWith(final State state) {
      T param = null;
      Object resultTemp = null;
      final Object initialParameter = state.completionHandler.completion().outcome();

      try {
        // debug("AF: EXECUTE-WITH: ID: " + id + " FOR: " + state.id() + " TYPE: " + type() + " STATUS: " + state().completionHandler.status() + " CASTING: " + initialParameter);
        param = (T) initialParameter;
        // debug("AF: EXECUTE-WITH: ID: " + id + " FOR: " + state.id() + " TYPE: " + type() + " STATUS: " + state().completionHandler.status() + " CAST TO: " + param);
        resultTemp = function.apply(param);
        // debug("AF: EXECUTE-WITH: ID: " + id + " FOR: " + state.id() + " COMPLETED WITH: " + resultTemp);
        final O result = (O) resultTemp;
        // debug("AF: EXECUTE-WITH: ID: " + id + " FOR: " + state.id() + " CAST TO: " + result);
        if (result instanceof Exception) {
          // debug("AF: EXECUTE-WITH: ID: " + id + " FOR: " + state.id() + " OUTCOME IS EXCEPTION: " + ((Exception) result).getMessage());
          setException((Exception) result);
          outcome = new AtomicReference<>(result);
          inform(false);
        } else {
          // debug("AF: EXECUTE-WITH: ID: " + id + " FOR: " + state.id() + " OUTCOME IS NORMAL: " + result);
          outcome = new AtomicReference<>(result);
          inform(true);
        }
      } catch (Exception e) {
        // debug("AF: EXECUTE-WITH: EXCEPTION: " + id + " FOR: " + state.id() + " TYPE: " + type() + " PARAM: " + param + " TEMP-RESULT: " + resultTemp + "\nEXCEPTION MESSAGE: " + e.getMessage() + printLimitedTrace(e, 0, 9999));
        setException(e);
        inform(false);
      }
    }

    @Override
    @SuppressWarnings("unchecked")
    public Optional<O> outcome() {
      if (outcome == null) {
        return Optional.empty();
      }

      return Optional.of(outcome.get());
    }

    @Override
    public void reset() {
      outcome = null;

      super.reset();
    }
  }

  private static class TerminalAction extends RunnableAction {
    public TerminalAction(final ActionType terminal, final String name, final State state) {
      super(terminal, name, state, null);
    }

    @Override
    public boolean isTerminal() {
      return true;
    }

    @Override
    public void executeWith(final State state) {
      throw new UnsupportedOperationException("");
    }
  }

  //////////////////////////////////////////////////////
  // CompletionRunner
  //////////////////////////////////////////////////////

  private static final CompletionRunner<State> messageQueueRunner = new CompletionRunnersPool();

  static CompletionRunner<State> messageQueueRunner() {
    return messageQueueRunner;
  }

  static class CompletionRunnersPool implements CompletionRunner<State> {
    private final AsyncMessageQueueCompletionRunner[] runners;

    CompletionRunnersPool() {
      this.runners = new AsyncMessageQueueCompletionRunner[DefaultTotalRunners];

      for (int idx = 0; idx < DefaultTotalRunners; ++idx) {
        runners[idx] = new AsyncMessageQueueCompletionRunner();
      }
    }

    @Override
    public void runWith(final Action<State> action) {
      final int runner = Math.abs(action.state().id().hashCode() % DefaultTotalRunners);
      runners[runner].runWith(action);
    }
  }

  static class AsyncMessageQueueCompletionRunner implements CompletionRunner<State>, MessageQueueListener {
    private final MessageQueue messageQueue;

    AsyncMessageQueueCompletionRunner() {
      this.messageQueue = new AsyncMessageQueue(null);
      this.messageQueue.registerListener(this);
    }

    @Override
    public void runWith(final Action<State> action) {
      // debug("R: RUN-WITH: ENQUEUING ACTION: " + ((RunnableAction) action).id() + " FOR: " + action.state().id() + " TYPE: " + action.type() + " STATUS: " + action.state().completionHandler.status() + " VALUE: " + action.state().completionHandler.outcome());
      messageQueue.enqueue(new ActionMessage(action));
    }

    @Override
    public void handleMessage(final Message message) throws Exception {
      final Action<State> action = message.payload();
      // debug("R: HANDLE-MESSAGE: EXECUTING ACTION: " + ((RunnableAction) action).id() + " FOR: " + action.state().id() + " TYPE: " + action.type() + " STATUS: " + action.state().completionHandler.status() + " VALUE: " + action.state().completionHandler.outcome());
      action.executeWith(action.state());
    }
  }

  static class ActionMessage implements Message {
    private final Action<State> action;

    ActionMessage(final Action<State> action) {
      this.action = action;
    }

    @Override
    public String id() {
      return action.state().id.toString();
    }

    @Override
    public Date occurredOn() {
      return new Date();
    }

    @Override
    @SuppressWarnings("unchecked")
    public <T> T payload() {
      return (T) action;
    }

    @Override
    public String type() {
      return Action.class.getName();
    }

    @Override
    public String version() {
      return "1.0.0";
    }
  }
}
