// Copyright Â© 2012-2020 VLINGO LABS. All rights reserved.
//
// This Source Code Form is subject to the terms of the
// Mozilla Public License, v. 2.0. If a copy of the MPL
// was not distributed with this file, You can obtain
// one at https://mozilla.org/MPL/2.0/.

package io.vlingo.common;

import java.util.concurrent.CountDownLatch;
import java.util.concurrent.TimeUnit;

import org.junit.Assert;
import org.junit.Test;

public class AsyncCompletesTest {
  private Integer andThenValue;
  private Integer failureValue;

  @Test
  public void testCompletesAsTyped() {
    final Completes<Integer> completes = Completes.asTyped();

    completes.with(5);

    completes.await();

    Assert.assertTrue(completes.isCompleted());
    Assert.assertFalse(completes.hasFailed());
    Assert.assertEquals(5, completes.outcome().intValue());
  }

  @Test
  public void testCompletesWith() {
    final Completes<Integer> completes = new AsyncCompletes<>(5, false);

    Assert.assertTrue(completes.isCompleted());
    Assert.assertTrue(completes.hasFailed());
    Assert.assertEquals(new Integer(5), completes.outcome());
  }

  @Test
  public void testCompletesAfterFunction() {
    final Completes<Integer> completes = Completes.asInteger();

    completes.andThen((value) -> value * 2);

    completes.with(5);

    completes.await();

    Assert.assertEquals(new Integer(10), completes.outcome());
  }

  @Test
  public void testCompletesAfterConsumer() {
    final Completes<Integer> completes = Completes.asInteger();

    completes.andThen((value) -> andThenValue = value);

    completes.with(5);

    completes.await();

    Assert.assertEquals(new Integer(5), completes.outcome());
  }

  @Test
  public void testCompletesAfterAndThen() {
    final Completes<Integer> completes = Completes.asInteger();

    completes
      .andThen((value) -> value * 2)
      .andThen((value) -> andThenValue = value);

    completes.with(5);

    completes.await();

    Assert.assertEquals(new Integer(10), andThenValue);
    Assert.assertEquals(new Integer(10), completes.outcome());
  }

  @Test
  public void testCompletesAfterAndThenMessageOut() {
    final Completes<Integer> completes = Completes.asInteger();

    final Holder holder = new Holder();

    completes
      .andThen((value) -> value * 2)
      .andThen((value) -> { holder.hold(value); return value; } );

    completes.with(5);

    completes.await();

    Assert.assertEquals(new Integer(10), andThenValue);
  }

  @Test
  public void testOutcomeBeforeTimeout() {
    final Completes<Integer> completes = new AsyncCompletes<>(new Scheduler());

    completes
      .andThen(1000, (value) -> value * 2)
      .andThen((value) -> andThenValue = value);

    completes.with(5);

    completes.await(10);

    Assert.assertEquals(new Integer(10), andThenValue);
  }

  @Test
  public void testTimeoutBeforeOutcome() throws Exception {
    final Completes<Integer> completes = new AsyncCompletes<>(new Scheduler());

    completes
      .andThen(1, 0, (value) -> value * 2)
      .andThen((value) -> andThenValue = value);

    Thread.sleep(100);

    completes.with(5);

    completes.await();

    Assert.assertTrue(completes.hasFailed());
    Assert.assertNotEquals(new Integer(10), andThenValue);
    Assert.assertNull(andThenValue);
  }

  @Test
  public void testThatFailureOutcomeFails() {
    final Completes<Integer> completes = new AsyncCompletes<>(new Scheduler());

    completes
      .andThen(null, (value) -> value * 2)
      .andThen((Integer value) -> andThenValue = value)
      .otherwise((failedValue) -> failureValue = 1000);

    completes.with(null);

    completes.await();

    Assert.assertTrue(completes.hasFailed());
    Assert.assertNull(andThenValue);
    Assert.assertEquals(new Integer(1000), failureValue);
  }

  @Test
  public void testThatNonNullFailureOutcomeFails() {
    final Completes<Integer> completes = new AsyncCompletes<>(new Scheduler());

    completes
            .andThen(new Integer(-100), (value) -> 2 * value)
            .andThen((x) -> andThenValue = x)
            .otherwise((x) -> failureValue = 1000);

    completes.with(-100);

    final Integer completed = completes.await();

    Assert.assertTrue(completes.hasFailed());
    Assert.assertEquals(new Integer(1000), completed);
    Assert.assertEquals(null, andThenValue);
    Assert.assertEquals(new Integer(1000), failureValue);
  }

  @Test
  public void testThatFluentTimeoutWithNonNullFailureTimesout() throws Exception {
    final Completes<Integer> completes = new AsyncCompletes<>(new Scheduler());

    completes
      .useFailedOutcomeOf(new Integer(-100))
      .timeoutWithin(1)
      .andThen(value -> 2 * value)
      .otherwise((Integer failedValue) -> failedValue.intValue() - 100);

    Thread.sleep(100);

    completes.with(5);

    final Integer failureOutcome = completes.await();

    Assert.assertTrue(completes.hasFailed());
    Assert.assertEquals(new Integer(-200), failureOutcome);
  }

  @Test
  public void testThatExceptionOutcomeFails() {
    System.out.println("==================== testThatExceptionOutcomeFails()");

    final Completes<Integer> completes = new AsyncCompletes<>(new Scheduler());

    completes
      .andThen(null, (value) -> value * 2)
      .andThen((Integer value) -> { System.out.println("{1}"); throw new IllegalStateException("" + (value * 2)); })
      .recoverFrom((e) -> { System.out.println("{2}"); failureValue = Integer.parseInt(e.getMessage()); return failureValue; });

    completes.with(2);

    final Integer outcome = completes.await();

    System.out.println("==================== testThatExceptionOutcomeFails()");

    Assert.assertNotNull(outcome);
    Assert.assertTrue(completes.hasFailed());
    Assert.assertNull(andThenValue);
    Assert.assertEquals(8, outcome.intValue());
    Assert.assertEquals(8, failureValue.intValue());
  }

  @Test
  public void testThatExceptionHandlerDelayRecovers() {
    final Completes<Integer> completes = new AsyncCompletes<>(new Scheduler());

    completes
      .andThen(null, (value) -> value * 2)
      .andThen((Integer value) -> { throw new IllegalStateException("" + (value * 2)); })
      .recoverFrom((e) -> {
        failureValue = Integer.parseInt(e.getMessage());
        return failureValue;
      });

    completes.with(10);

    completes.await();

    Assert.assertTrue(completes.hasFailed());
    Assert.assertNull(andThenValue);
    Assert.assertEquals(new Integer(40), failureValue);
  }

  @Test
  public void testThatAwaitTimesout() throws Exception {
    final Completes<Integer> completes = new AsyncCompletes<>(new Scheduler());

    final Integer completed = completes.await(10);

    completes.with(5);

    Assert.assertNotEquals(new Integer(5), completed);
    Assert.assertNull(completed);
  }

  @Test
  public void testThatAwaitCompletes() throws Exception {
    final Completes<Integer> completes = new AsyncCompletes<>(new Scheduler());

    new Thread() {
      @Override
      public void run() {
        try {
          Thread.sleep(100);
          completes.with(5);
        } catch (Exception e) {
          // ignore
        }
      }
    }.start();

    final Integer completed = completes.await();

    Assert.assertEquals(new Integer(5), completed);
  }

  @Test
  public void testInvertWithFailedOutcome() throws InterruptedException {
    final Outcome<RuntimeException, Completes<String>> failed = Failure.of(new RuntimeException("boom"));
    Completes<Outcome<RuntimeException, String>> inverted = Completes.invert(failed);
    CountDownLatch latch = new CountDownLatch(1);
    inverted.otherwiseConsume(outcome -> {
      Assert.assertTrue("was not Failure", outcome instanceof Failure);
      Assert.assertNull("was not null", outcome.getOrNull());
      Assert.assertEquals("was not the expected error message", "boom", outcome.otherwise(Throwable::getMessage).get());
      latch.countDown();
    });
    Assert.assertTrue("timed out", latch.await(1, TimeUnit.SECONDS));
  }

  @Test
  public void testInvertWithSuccessOutcomeOfSuccessCompletes() throws InterruptedException {
    final Outcome<RuntimeException, Completes<String>> success = Success.of(Completes.withSuccess("YAY"));
    Completes<Outcome<RuntimeException, String>> inverted = Completes.invert(success);
    CountDownLatch latch = new CountDownLatch(1);
    inverted.andThenConsume(outcome -> {
      Assert.assertTrue("was not Success", outcome instanceof Success);
      Assert.assertNotNull("was null", outcome.getOrNull());
      Assert.assertEquals("was not the expected value", "YAY", outcome.get());
      latch.countDown();
    });
    Assert.assertTrue("timed out", latch.await(1000, TimeUnit.SECONDS));
  }

  @Test
  public void testInvertWithSuccessOutcomeOfFailedCompletes() throws InterruptedException {
    final Outcome<RuntimeException, Completes<String>> successfulFailure = Success.of(Completes.withFailure("ERROR"));
    Completes<Outcome<RuntimeException, String>> inverted = Completes.invert(successfulFailure);
    Assert.assertTrue("hasn't failed", inverted.hasFailed());
    CountDownLatch latch = new CountDownLatch(1);
    inverted.andThenConsume(outcome -> latch.countDown());
    Assert.assertFalse("din't timeout", latch.await(1, TimeUnit.MILLISECONDS));
  }

  @Test
  public void testLoneAndThenToCompletes() {
    final Completes<Integer> completes = new AsyncCompletes<>(new Scheduler());

    Completes<Integer> another =
      completes
        .andThenTo(value -> { System.out.println("AND-THEN-TO: " + (value * 2)); return Completes.withSuccess(value * 2); });

    System.out.println("COMPLETES ID: " + completes.id());

    Assert.assertEquals(completes.id(), another.id());

    final int value = 5;
    completes.with(value);

    final Integer outcome = completes.await();

    Assert.assertFalse(another.hasFailed());
    Assert.assertNull(andThenValue);
    Assert.assertEquals(new Integer(10), outcome);
  }

  @Test
  public void testAndThenAndThenToCompletes() {
    final Completes<Integer> completes = new AsyncCompletes<>(new Scheduler());

    Completes<Integer> another =
      completes
        .andThen(value -> value * 2)
        .andThenTo(value -> Completes.withSuccess(value * 2));

    Assert.assertEquals(completes.id(), another.id());

    final int value = 5;
    completes.with(value);

    final Integer outcome = completes.await();

    Assert.assertFalse(completes.hasFailed());
    Assert.assertNull(andThenValue);
    Assert.assertEquals(new Integer(20), outcome);
  }

  @Test
  public void testAndThenAndThenToAndThenToAndThenCompletes() {
    final Completes<Integer> completes = new AsyncCompletes<>(new Scheduler());

    Completes<Integer> another =
      completes
        .andThen(value -> value * 2)
        .andThenTo(value -> Completes.withSuccess(value * 2))
        .andThenTo(value -> Completes.withSuccess(value * 2))
        .andThen(value -> value * 2);

    Assert.assertEquals(completes.id(), another.id());

    final int value = 5;
    completes.with(value);

    final Integer outcome = completes.await();

    Assert.assertFalse(completes.hasFailed());
    Assert.assertNull(andThenValue);
    Assert.assertEquals(new Integer(80), outcome);
  }

  @Test
  public void testAndThenAndThenToAndThenToAndThenCrashCompletes() {
    System.out.println("==================== testAndThenAndThenToAndThenToAndThenCrashCompletes()");

    final Completes<Integer> completes = new AsyncCompletes<>(new Scheduler());

    Completes<Integer> another =
      completes
        .andThen(value -> value * 2)
        .andThenTo(value -> Completes.withSuccess(value * 2))
        .andThenTo(value -> Completes.withSuccess(value * 2))
        .andThen(value -> multipleBy(value, 2))
        .andThen((Integer value) -> value * 2)
        .recoverFrom(e -> Integer.parseInt(e.getMessage()));

    Assert.assertEquals(completes.id(), another.id());

    final int value = 5;
    completes.with(value);

    final Integer outcome = completes.await();

    System.out.println("==================== testAndThenAndThenToAndThenToAndThenCrashCompletes()");

    Assert.assertFalse(completes.hasFailed());
    Assert.assertNull(andThenValue);
    Assert.assertEquals(1000, outcome.intValue());
  }

  private int multipleBy(final int amount, final int by) {
    throw new IllegalStateException("1000");
  }

  private class Holder {
    private void hold(final Integer value) {
      andThenValue = value;
    }
  }
}
